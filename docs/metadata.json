{
  "version": "1.0.0",
  "lastUpdated": "2026-02-28",
  "documents": [
    {
      "id": "architecture",
      "path": "docs/architecture.md",
      "title": "アーキテクチャ設計",
      "description": "NestJS BFF の全体構成、Axiosインスタンス統合、例外処理設計、DTOの使い分け方針",
      "tags": ["アーキテクチャ", "設計", "BFF", "NestJS"],
      "industry": ["IT"],
      "topics": ["Axios統合", "ExceptionFilter", "SharedModule", "DTO", "インターセプター"],
      "updatedAt": "2026-02-23"
    },
    {
      "id": "setup",
      "path": "docs/setup.md",
      "title": "セットアップ",
      "description": "依存パッケージインストール、環境変数設定、クライアントコード生成、開発サーバー起動手順",
      "tags": ["セットアップ", "環境構築", "インストール"],
      "industry": ["IT"],
      "topics": ["npm install", "env", "gen:all", "openapi-generator", "トラブルシューティング"],
      "updatedAt": "2026-02-23"
    },
    {
      "id": "development",
      "path": "docs/development.md",
      "title": "開発ガイド",
      "description": "新しいエンドポイントの追加手順、手書きDTOの実装方法、ファイルアップロードプロキシの実装パターン、検証手順、ファイル構造の規約",
      "tags": ["開発", "実装", "ガイド"],
      "industry": ["IT"],
      "topics": ["エンドポイント追加", "DTO", "class-validator", "コード生成", "テスト", "FileInterceptor", "multipart", "FormData", "MulterModule", "UPLOAD_MAX_FILE_SIZE", "ParseFilePipe"],
      "updatedAt": "2026-02-28"
    },
    {
      "id": "response-filtering",
      "path": "docs/response-filtering.md",
      "title": "レスポンス DTO フィルタリング",
      "description": "Over-fetchingを防ぐための手書きレスポンスDTO実装パターン。@Expose() + plainToInstance + excludeExtraneousValues: true による公開フィールド制御",
      "tags": ["セキュリティ", "DTO", "class-transformer", "レスポンス"],
      "industry": ["IT"],
      "topics": ["plainToInstance", "Expose", "excludeExtraneousValues", "ClassSerializerInterceptor", "Over-fetching"],
      "updatedAt": "2026-02-23"
    }
    ,{
      "id": "bff-design-philosophy",
      "path": "docs/bff-design-philosophy.md",
      "title": "BFF 設計の2つの流儀",
      "description": "Thin BFF と Thick BFF（Repositoryパターン）の構造・メリット・デメリット、型エラー伝播の違い、スクリプトで検出できない意味的不整合、採用判断の基準",
      "tags": ["設計", "BFF", "アーキテクチャ", "Repositoryパターン"],
      "industry": ["IT"],
      "topics": ["ThinBFF", "ThickBFF", "Adapterパターン", "型安全性", "意味的不整合", "設計判断"],
      "updatedAt": "2026-02-23"
    }
    ,{
      "id": "rate-limiting",
      "path": "docs/rate-limiting.md",
      "title": "レート制限",
      "description": "@nestjs/throttler による IP ベースのレート制限の仕組み・設定方法・エンドポイント単位でのオーバーライド方法",
      "tags": ["セキュリティ", "レート制限", "throttler"],
      "industry": ["IT"],
      "topics": ["ThrottlerGuard", "APP_GUARD", "THROTTLE_TTL", "THROTTLE_LIMIT", "429"],
      "updatedAt": "2026-02-23"
    }
    ,{
      "id": "health-check",
      "path": "docs/health-check.md",
      "title": "ヘルスチェック",
      "description": "@nestjs/terminus による HTTP pingCheck の仕組み・レスポンス形式・インジケーター追加方法",
      "tags": ["監視", "ヘルスチェック", "terminus"],
      "industry": ["IT"],
      "topics": ["HealthCheckService", "HttpHealthIndicator", "pingCheck", "503", "監視"],
      "updatedAt": "2026-02-23"
    }
    ,{
      "id": "mock-mode",
      "path": "docs/mock-mode.md",
      "title": "開発用モック・スタブモード",
      "description": "MOCK_MODE=true で fixtures/ の JSON ファイルをレスポンスとして返す仕組み・フィクスチャ命名規則・MockInterceptor の実装詳細",
      "tags": ["開発", "テスト", "モック"],
      "industry": ["IT"],
      "topics": ["MockInterceptor", "MOCK_MODE", "fixtures", "スタブ", "開発効率"],
      "updatedAt": "2026-02-23"
    }
    ,{
      "id": "why-bff",
      "path": "docs/why-bff.md",
      "title": "BFF を使う理由：BFFなし vs BFFあり",
      "description": "BFF（Backend for Frontend）を導入する利点と注意点を比較表で整理。通信回数・セキュリティ・型安全性・チーム分業・デプロイ独立性の観点から解説",
      "tags": ["BFF", "設計", "アーキテクチャ", "比較"],
      "industry": ["IT"],
      "topics": ["BFF", "APIキー", "型安全性", "セキュリティ", "チーム分業", "デプロイ"],
      "updatedAt": "2026-02-23"
    }
    ,{
      "id": "structured-logging",
      "path": "docs/structured-logging.md",
      "title": "構造化ロギングと Correlation ID 伝播",
      "description": "nestjs-pino による JSON 構造化ロギングの仕組み・設定方法、x-request-id を用いた Correlation ID 伝播パターン、AsyncLocalStorage によるリクエストコンテキスト管理、ログレベル制御",
      "tags": ["ロギング", "監視", "nestjs-pino", "可観測性"],
      "industry": ["IT"],
      "topics": ["nestjs-pino", "pino-http", "pino-pretty", "AsyncLocalStorage", "CorrelationID", "x-request-id", "LoggerModule", "InjectPinoLogger", "LOG_LEVEL"],
      "updatedAt": "2026-02-25"
    }
    ,{
      "id": "express-middleware",
      "path": "docs/express-middleware.md",
      "title": "Express ミドルウェアと req / res / next",
      "description": "Express ミドルウェアの req・res・next 3 引数の役割、ミドルウェアチェーンの仕組み、next() を呼ばない場合の挙動、関数型とクラス型の違い、このプロジェクトの correlationIdMiddleware での活用、テスト方法",
      "tags": ["Express", "ミドルウェア", "NestJS", "テスト"],
      "industry": ["IT"],
      "topics": ["req", "res", "next", "NextFunction", "NestMiddleware", "correlationIdMiddleware", "app.use", "関数型ミドルウェア"],
      "updatedAt": "2026-02-25"
    }
    ,{
      "id": "arguments-host",
      "path": "docs/arguments-host.md",
      "title": "ArgumentsHost",
      "description": "NestJS の ExceptionFilter に渡される ArgumentsHost の役割・switchToHttp() による req/res 取得・このプロジェクトでの使用箇所（AxiosExceptionFilter）・テストでのモック方法",
      "tags": ["NestJS", "ExceptionFilter", "テスト", "アーキテクチャ"],
      "industry": ["IT"],
      "topics": ["ArgumentsHost", "ExceptionFilter", "switchToHttp", "HttpArgumentsHost", "AxiosExceptionFilter", "モック"],
      "updatedAt": "2026-02-25"
    }
    ,{
      "id": "axios-interceptors",
      "path": "docs/axios-interceptors.md",
      "title": "Axios インターセプター",
      "description": "Axios インターセプターの仕組み・動作フロー、AuthHeaderInterceptor/LoggingInterceptor/MockInterceptor の役割と実装詳細、NestJS NestInterceptor との使い分け、multipart/form-data のバイナリボディスキップ、テスト方法",
      "tags": ["Axios", "インターセプター", "アーキテクチャ", "BFF"],
      "industry": ["IT"],
      "topics": ["AxiosInterceptor", "OnModuleInit", "HttpService", "AuthHeader", "Logging", "MockMode", "横断的関心事", "bodyLogged", "multipart"],
      "updatedAt": "2026-02-28"
    }
    ,{
      "id": "testing-strategy",
      "path": "docs/testing-strategy.md",
      "title": "テスト戦略",
      "description": "Thin BFF においてなぜ Controller/Service テストを省略するか、テストする価値があるインフラ層の責務、Axiosキャプチャ・PinoLogger・ArgumentsHost・Plain関数のモックパターン集、カバレッジ設定の根拠と将来の API 追加時のガイドライン",
      "tags": ["テスト", "品質", "テスト戦略", "Jest"],
      "industry": ["IT"],
      "topics": ["ユニットテスト", "カバレッジ", "ExceptionFilter", "Interceptor", "Middleware", "Jest", "モック", "AsyncLocalStorage"],
      "updatedAt": "2026-02-25"
    }
    ,{
      "id": "jwt-authentication",
      "path": "docs/jwt-authentication.md",
      "title": "JWT 認証",
      "description": "クライアント→BFF 間の JWT Bearer Token 検証の仕組み・設定方法・@Public() デコレータ（独自実装）によるエンドポイント単位のスキップ、JwtAuthGuard の有効化手順、401 レスポンス形式、k8s / API Gateway / Service Mesh との役割分担・トレードオフ",
      "tags": ["セキュリティ", "認証", "JWT", "Guard", "インフラ", "k8s"],
      "industry": ["IT"],
      "topics": ["JwtAuthGuard", "JWT_AUTH_ENABLED", "JWT_SECRET", "PassportStrategy", "APP_GUARD", "Public", "401", "SetMetadata", "Reflector", "APIGateway", "ServiceMesh", "mTLS", "認可"],
      "updatedAt": "2026-02-27"
    }
    ,{
      "id": "guard-interceptor-middleware",
      "path": "docs/guard-interceptor-middleware.md",
      "title": "Guard / Interceptor / Middleware",
      "description": "NestJS のリクエスト処理パイプラインにおける Guard・Interceptor・Middleware の役割の違い・実行順序・選び方の判断基準。このプロジェクトでの実装例（JwtAuthGuard・UserContextInterceptor・correlationIdMiddleware）を交えて解説",
      "tags": ["NestJS", "アーキテクチャ", "Guard", "Interceptor", "ミドルウェア"],
      "industry": ["IT"],
      "topics": ["Guard", "Interceptor", "Middleware", "canActivate", "NestInterceptor", "ExecutionContext", "APP_GUARD", "APP_INTERCEPTOR", "実行順序", "認証", "認可"],
      "updatedAt": "2026-02-28"
    }
    ,{
      "id": "multi-backend",
      "path": "docs/multi-backend.md",
      "title": "複数バックエンドへの動的ルーティング",
      "description": "マイクロサービス構成で複数バックエンドへルーティングする方法。createApiProvider ファクトリによる DI トークン管理、単一 axiosRef 共有でインターセプターを全バックエンドに適用する仕組み、バックエンド追加手順",
      "tags": ["アーキテクチャ", "マイクロサービス", "ルーティング", "DI"],
      "industry": ["IT"],
      "topics": ["createApiProvider", "DI", "Symbol", "BaseURL", "HttpService", "axiosRef", "マイクロサービス", "複数バックエンド", "環境変数"],
      "updatedAt": "2026-02-28"
    }
  ]
}
