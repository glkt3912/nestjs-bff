# BFF を使う理由：BFFなし vs BFFあり

BFF（Backend for Frontend）とは、フロントエンドのために最適化された API ゲートウェイです。
バックエンドと UI の間に専用レイヤーを置くことで、通信の集約・セキュリティ・型設計・チーム分業を改善できます。

---

## 比較表

| 項目 | BFFなし（直接呼出） | BFFあり |
| --- | --- | --- |
| 通信回数 | 複数回（低速になりやすい） | 1回（集約・高速） |
| ロジックの場所 | フロントに加工ロジックが散らばる | BFFに集約、フロントは表示に専念 |
| セキュリティ | APIキー等をフロントが知る必要がある | BFF内で完結し、フロントは安全 |
| 型安全性 | バックエンドの都合に引きずられる | UIに最適な型をTypeScriptで定義できる |
| チーム分業 | フロント↔バックエンドの調整が密結合 | BFFチームが境界を担い分業しやすい |
| デプロイ独立性 | バックエンドと足並みを揃える必要がある | BFFを独立してリリースできる |
| インフラコスト | BFFサーバー不要 | BFFの追加ホスティングコストが発生 |

---

## 各項目の詳細解説

### 通信回数の集約（BFF の中核価値）

BFFなしの場合、フロントは「ユーザー情報」「注文履歴」「在庫状況」など複数のバックエンド API を
個別に呼び出す必要があります。ネットワーク往復が増え、処理が遅くなりがちです。

BFFがあれば、フロントからの1回のリクエストをトリガーに BFF が複数バックエンドを並列呼出し、
結果をまとめてレスポンスします。これを **Aggregation パターン** と呼びます。

### ロジックの場所（Separation of Concerns）

BFFなしでは、フロントに `map()` / `filter()` / データ結合ロジックが混在します。
UI コンポーネントが「データの表示」と「データの加工」を両方担うことになり、
コードの見通しが悪くなります。

BFFがあれば、フロントは「受け取ったデータを表示するだけ」に専念できます。
関心の分離（Separation of Concerns）が達成され、フロントのコードが簡潔になります。

### セキュリティ（機密情報の秘匿）

BFFなしでは、バックエンドへの `Authorization` ヘッダや API KEY をフロント（ブラウザ）が保持します。
ブラウザは DevTools で誰でも閲覧できるため、機密情報の漏洩リスクがあります。

BFFがあれば、APIキーやサービストークンは BFF サーバー内に閉じておけます。
フロントは BFF との通信に Cookie / Session トークンだけを使えばよく、
機密情報がブラウザに届くことはありません。

### 型安全性（UI ドリブンな型設計）

BFFなしでは、バックエンドが返す過剰なフィールドをフロントが型定義しなければなりません。
バックエンドの内部都合（DB スキーマの変更など）が型に即波及します。

BFFがあれば、フロントに必要な型を UI の観点で独立して設計できます。
このリポジトリでは `@Expose()` + `plainToInstance(..., { excludeExtraneousValues: true })` を使い、
フロントに渡すフィールドを明示的に制御しています（詳細は [response-filtering.md](./response-filtering.md)）。

### チーム分業

BFFなしでは、バックエンドのレスポンス仕様変更がフロントに即波及します。
フロントとバックエンドのチームが常に連絡を取り合う必要があり、並行開発が難しくなります。

BFFがあれば、BFF がバックエンドとフロントの差分を吸収します。
バックエンドチームは BFF との契約（API仕様）さえ守れば内部を自由に変更でき、
フロントチームも BFF のレスポンスだけを考えればよくなります。

### デプロイ独立性

BFFなしでは、バックエンドのレスポンス形式が変わるとフロントも同時に修正・デプロイが必要です。
リリースのタイミングを合わせる調整コストが生じます。

BFFがあれば、BFF を先にデプロイして新旧バックエンドをアダプトすることも、
フロントを先にデプロイして BFF 側で機能フラグを持つことも可能です。
それぞれを独立したリリースサイクルで運用できます。

### デメリット：インフラコスト・複雑性

BFF を導入することで以下のデメリットも生じます。

- **単一障害点（Single Point of Failure）**: BFF がダウンするとフロントがすべての機能を失う
- **ホスティングコスト**: BFF サーバーの追加インフラコスト・ログ・監視が必要
- **設計コスト**: 小規模・個人プロジェクトでは過剰設計になる場合がある

---

## いつ BFF を使うか（判断基準）

| 条件 | 推奨 |
| --- | --- |
| フロントが複数バックエンドを呼び出す | **BFFあり** |
| APIキーをフロントに持ちたくない | **BFFあり** |
| フロント・バックエンドを別チームが担当 | **BFFあり** |
| モバイル・Web で異なる UI 最適化が必要 | **BFFあり**（デバイス別 BFF） |
| 小規模・個人プロジェクト | **BFFなし**（シンプルさ優先） |
| バックエンドが1つで変更が少ない | **BFFなし** |

---

## このリポジトリの立場

このリポジトリの NestJS BFF は以下の理由で BFF パターンを採用しています。

1. **APIキー秘匿**: バックエンドサービスのトークン・キーを BFF サーバー側に閉じ、フロントには漏らさない
2. **レスポンス最適化（Over-fetching 防止）**: `@Expose()` + `plainToInstance` でフロントに必要なフィールドだけを渡す
3. **型の UI 最適化**: バックエンドの型に縛られず、UI の観点で TypeScript 型を設計できる

---

## 関連ドキュメント

- [bff-design-philosophy.md](./bff-design-philosophy.md) — BFF を採用した後の実装スタイル（Thin BFF vs Thick BFF）
- [response-filtering.md](./response-filtering.md) — 型安全性・Over-fetching 防止の具体的実装
